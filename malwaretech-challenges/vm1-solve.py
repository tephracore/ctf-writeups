# Author : taha@tephracore.com
# copyright 2019 - All rights reserved

from idaapi import *

xor_key = 0 # initializing xor key with zero will have no effect on the result

def one(operand1, operand2, vm_offset):
	PatchByte(vm_offset+operand1, operand2)
	print "mov eax, %#x" % (vm_offset+operand1)
	print "mov [eax], %#x" % operand2
	return "opcode: 1"

def two(operand1, operand2, vm_offset):
	global xor_key
	xor_key = Byte(vm_offset + operand1)
	print "mov byte_global, %#x" % xor_key	
	return "opcode: 2"
	
def three(operand1, operand2, vm_offset):
	print "mov eax, %#x" % (vm_offset+operand1)
	print "xor %#x, [eax]" % xor_key
	res = xor_key ^ Byte(vm_offset + operand1)
	print "mov [eax], %#x" % res
	PatchByte(vm_offset+operand1, res)
	return "opcode: 3"

def vm_interpreter(code, operand1 , operand2, vm_offset):
	
	opcode = {
		1: one,
		2: two,
		3: three
	}
	
	callback = opcode.get(code, lambda operand1, operand2, vm_offset: "invalid opcode")

	return callback(operand1, operand2, vm_offset)

def parse_vm_bytecode(vm_offset, size):
	jmp = 0xff # vm virutal address bytecode offset 
	vm_code = vm_offset + 0xff
	counter = 0
	
	while(counter <= size - 3 - 0xff):
			opcode = Byte(vm_code+counter)
			counter += 1
			operand1 = Byte(vm_code+counter)
			counter += 1
			operand2 = Byte(vm_code+counter)
			vm_interpreter(opcode, operand1, operand2,vm_offset)
			counter += 1

def print_flag(vm_offset):
	print GetString(vm_offset, -1, ASCSTR_C)

def decode_vm(vm_offset, size):
	parse_vm_bytecode(vm_offset, size)
	print_flag(vm_offset)

decode_vm(0x404040, 0x1fb) #call decode_vm (start of vm, size of vm)